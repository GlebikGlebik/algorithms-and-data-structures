# Задача 3: Подсчет инверсий в массиве

## Описание

Данная задача включает реализацию алгоритма сортировки слиянием с модификацией для подсчета инверсий в массиве. Инверсия в массиве — это ситуация, когда в последовательности чисел два элемента расположены в неправильном порядке, то есть первый элемент больше второго, но при этом находится перед ним. Основной целью является подсчет общего количества инверсий в заданном массиве.

### Описание файлов:

- **src/number_of_inversions.py**: Основной скрипт с реализацией алгоритма сортировки слиянием для подсчета инверсий. Читает данные из файла `input.txt` и записывает количество инверсий в файл `output.txt`.
- **txtf/input.txt**: Входной файл, содержащий количество элементов и сам массив чисел, для которого необходимо подсчитать количество инверсий.
- **txtf/output.txt**: Выходной файл, содержащий количество инверсий в массиве.
- **tests/test_number_of_inversions.py**: Модуль с тестами для проверки корректности работы алгоритма подсчета инверсий.

## Код задачи

```python
import time
import tracemalloc

tracemalloc.start()

"""
with open("../txtf/input.txt", "w") as f:
    n = input()
    a = input().split()
    f.write(n)
    f.write("\n")
    f.write(" ".join(a))
"""

start = time.perf_counter()


def merge_and_count(arr, left, mid, right):
    left_part = arr[left:mid + 1]
    right_part = arr[mid + 1:right + 1]
    i = j = 0
    inversions = 0
    temp = []
    while i < len(left_part) and j < len(right_part):
        if left_part[i] <= right_part[j]:
            temp.append(left_part[i])
            i += 1
        else:
            temp.append(right_part[j])
            j += 1
            inversions += len(left_part) - i

    while i < len(left_part):
        temp.append(left_part[i])
        i += 1
    while j < len(right_part):
        temp.append(right_part[j])
        j += 1
    for i, val in enumerate(temp):
        arr[left + i] = val

    return inversions


def merge_sort_and_count(arr, left, right):
    inversions = 0
    if left < right:
        mid = (left + right) // 2
        inversions += merge_sort_and_count(arr, left, mid)
        inversions += merge_sort_and_count(arr, mid + 1, right)
        inversions += merge_and_count(arr, left, mid, right)
    return inversions


with open("../txtf/input.txt", "r") as f:
    n = int(f.readline())
    arr = list(map(int, f.readline().split()))

inversions = merge_sort_and_count(arr, 0, n - 1)

with open("../txtf/output.txt", "w") as f:
    f.write(str(inversions) + "\n")

end = time.perf_counter()

print("Время работы: ", end - start, "секунд")
current, peak = tracemalloc.get_traced_memory()
print(f"Пиковая память: {peak / 2**20:.2f} MB")
tracemalloc.stop()


```

## Как запустить проект

1. **Установка зависимостей**: Проект не требует дополнительных зависимостей, кроме стандартной библиотеки Python.

2. **Запуск алгоритма подсчета инверсий**:

   - Перейдите в директорию `Task3/src`.
   - Убедитесь, что файл `input.txt` содержит корректные входные данные. Формат файла:
     - Первая строка содержит число `n` (количество элементов массива).
     - Вторая строка содержит `n` целых чисел, разделенных пробелами.
   - Выполните команду:
     ```sh
     python inversions_count.py
     ```
   - Результат будет записан в файл `output.txt`.

3. **Запуск тестов**:

   - Перейдите в директорию `Task3/tests`.
   - Выполните команду:
     ```sh
     python -m unittest test_inversions_count.py
     ```
   - Все тесты должны завершиться успешно, подтверждая корректность работы алгоритма.

## Формат входных и выходных данных

- **Входной файл (********`input.txt`********)**:

  - Первая строка: число `n` ( ≤ `n` ≤ 2 ⋅ 10⁴) — количество элементов массива.
  - Вторая строка: `n` различных целых чисел, по модулю не превосходящих `10⁹`.

- **Выходной файл (********`output.txt`********)**:

  - Содержит одно число — количество инверсий в массиве.

## Описание алгоритма

Алгоритм подсчета инверсий основан на сортировке слиянием с дополнительной функциональностью для подсчета количества инверсий. Основные этапы алгоритма:

1. **Разделение**: Деление массива на две части, пока размер подмассивов не станет равным единице.
2. **Подсчет и слияние**: На этапе слияния отсортированных подмассивов происходит подсчет инверсий. Если элемент в правом подмассиве меньше элемента в левом подмассиве, это означает наличие инверсий.
3. **Комбинирование**: Слияние двух отсортированных подмассивов в один.

Функция `merge_and_count` отвечает за подсчет инверсий при слиянии, а `merge_sort_and_count` — за рекурсивное разбиение массива и подсчет инверсий.

## Тестирование

Для проверки работоспособности алгоритма реализованы юнит-тесты в файле `test_number_of_inversions.py`. Тесты включают:

- Подсчет инверсий в обычных массивах.
- Проверку на уже отсортированный массив.
- Обратный порядок элементов.
- Пустой массив.
- Проверку на некорректные входные данные и размеры временного массива.

Запуск тестов позволяет убедиться в корректности работы функции для различных сценариев.

## Примеры

Пример входного файла (`input.txt`):

```
5
1 20 6 4 5
```

Пример выходного файла (`output.txt`) после выполнения:

```
5
```
